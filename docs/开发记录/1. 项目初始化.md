# 0x00 项目初始化

本 Task 将从 0 开始（完全的新建文件夹），创建出一个基于 Monorepo 组织方式、采用 React 18 + TS + Vite + Shadcn UI + Tailwind CSS + i18next + React Router 的 Hello World 项目。

1. 创建一个`monorepo`项目。
2. 使用 Vite 创建 React 项目

## 0. 前置准备

- 安装 Node.js：`scoop install nodejs-lts` -> Node.js v24.11.1（不能安装`nodejs`，这个不带 Corepack）
- 安装 pnpm：使用 Corepack 安装管理，`corepack enable` -> `corepack prepare pnpm@latest --activate` -> pnpm v10.23.0
  > 1. pnpm 相比 npm 是一种更先进的包管理工具。其不止更快速，并且有依赖全局安装、包隔离机制、monorepo 支持等优点。
  > 2. Corepack 是 Node.js 自带的管理“包管理工具”的工具，管理 npm、pnpm、yarn 这些包管理工具。可以确保不污染环境、团队版本一致。

## 1. 创建 monorepo 项目

> 为什么想用 monorepo：
>
> 我最早是在[OHIF Viewer](https://github.com/OHIF/Viewers)中看到的 monorepo 这个概念，将多个项目都放在一个仓库中管理，感觉这种管理方式很直观便捷、能最大规模复用，更为关键的是：符合一个业务项目/解决方案的管理方式。  
> 在之前用 Visual Studio 开发[桌面应用（WPF + ASP.NET Core）时](https://github.com/SuperSASS/CourseDesign)，也是一个解决方案里将 frontend、backend、shared 放在一起，与 monorepo 的概念不谋而合。  
> 因此在本次项目中，为也想在 Web 应用中自行学习使用 monorepo 的方式。
>
> 目前采用 monorepo，可以带来很大的扩展性，比如需要开发商家后台、扩展 UI 组件等，更多的优劣可能需要以后在实际的、具有体量的项目中才能体会到。

首先自行创建`package.json`文件，这个`package.json`文件是整个 monorepo 的根`package.json`，相当于总管家，  
与传统 Web 项目里的`package.json`不同，这个只是宏观调控，不负责具体某个项目的业务逻辑。

编写以下最小内容：

```json
{
  "name": "cockleboat-e-shop",
  "version": "1.0.0",

  // 1. 核心属性：private
  // 必须设为 true！
  // 原因：Monorepo 的根目录通常只是一个容器，不应该被发布到 npm 仓库。
  // 如果不加这个，万一你手滑敲了 npm publish，整个项目源码可能就泄露了。
  "private": true,

  "description": "Cockleboat's E-Shop based on React 18 + TypeScript + Vite + shadcn/ui, with Monorepo organization.",

  // 2. 脚本中心 (Scripts)
  // 这里的脚本是用来“指挥”子应用的。
  "scripts": {
    // "pnpm -r": recursive，递归地在所有子包中运行命令
    // "--parallel": 并行运行，速度更快
    // 效果：一键启动 apps/ 下的所有应用（比如以后有商家端、用户端，可以同时启动）
    "dev": "pnpm -r --parallel dev",
    // 一键构建所有子应用
    "build": "pnpm -r build",
    // 一键运行所有测试
    "test": "pnpm -r test",
    // 一键检查所有代码规范
    "lint": "pnpm -r lint",
    // 使用 Prettier 格式化整个项目的所有文件
    "format": "prettier --write .",
    // Husky 的钩子安装脚本，用于 Git 提交前的自动检查
    "prepare": "husky install"
  },

  // 3. 开发依赖 (devDependencies)
  // 这些工具是“整个项目通用”的。
  // 子应用不需要单独安装 eslint/prettier，直接复用根目录的配置即可。
  "devDependencies": {
    // 规范 Git 提交信息 (feat: xxx)
    "@commitlint/cli": "^20.1.0",
    "@commitlint/config-conventional": "^20.0.0",
    // 代码检查工具
    "eslint": "^9.39.1",
    // ESLint 插件
    "@eslint/js": "^9.39.1",
    "globals": "^16.5.0",
    // 只检查变更的代码
    "lint-staged": "^16.2.7",
    // Git Hooks 工具 (提交前自动 lint)
    "husky": "^9.1.7",
    // 代码格式化工具
    "prettier": "^3.6.2",
    // Prettier 排序 Tailwind 的类名
    "prettier-plugin-tailwindcss": "^0.7.1"
  }
}
```

**pnpm 的 Workspace 机制**：

配合 pnpm-workspace.yaml (内容是 packages: ['apps/*', 'packages/*'])，pnpm 会自动识别这些目录下的文件夹为“子工程”。
当你在根目录运行 pnpm install 时，它会把所有子工程的依赖都安装好，并把它们“软链接”在一起。

**更新为最新的 npm 包**：

由于是全新项目，可以用`pnpm up --latest`将所有包更新为最新版本。

## 2. 使用 Vite 创建 React 项目

Vite 基本上是目前最佳构建工具，个人体验主要是非常快，其它具体优点可以后续学习，这里可以“无脑用”。

```bash
mkdir apps # 子项目目录（对本项目来说只有一个 shop-web）
mkdir packages # 包项目目录（如 ui, i18n 等）

npm create vite@latest apps/shop-web
```

然后：

- framework: React
- variant: TypeScript + SWC
  > SWC 是用 Rust 语言编写的编译/构建器，是传统 Babel 的上位代替，速度极快。  
  > 不会影响代码的编写，是无感的，也更推荐使用，可以无脑选择。
  >
  > 注：React Compiler 可用于自动优化性能（`useMemo`、`useCallback` 等），但对底层渲染机制学习作弊了，并且是最新技术可能有坑，故不启用。
- rolldown-vite: No（不知道是什么，但实验性的先不启用）
- Install with npm and start now?: Yes

等待安装完成后，看见 Hello world 项目：

![Hello world](<images/image-1. 项目初始化.png>)

将基于本 Hello world 项目，一步步搭建出我们最终的电商平台。

## 3. 配置底座包

### 1. UI: Tailwind CSS + Shadcn UI

采用 Tailwind CSS + Shadcn UI。  
参考 [Shadcn UI安装方式](https://ui.shadcn.com/docs/installation/vite)，使用 Tailwind v4：

1. 安装 Tailwind CSS

```bash
pnpm add tailwindcss @tailwindcss/vite # 注意：pnpm 安装包用 add，而非 npm 的 install
```

2. 替换`index.css`内容为`@import "tailwindcss";`
3. 按教程修改`tsconfig.json`
4. 按教程修改`tsconfig.app.json`
5. 按教程修改`vite.config.ts`
6. `pnpm dlx shadcn@latest init`
   - base color: Neutral

到目前，已经安装了 UI 相关包。  
但需要注意：目前并没遵从 monorepo 的方式，通过`pnpm dlx shadcn@latest add [COMPONENT]`安装的组件会放到`apps/shop-web/src/components/ui`中。  
但按照 KISS 原则，目前先这么做、跑起来，以后再进行组件抽取。

1. `pnpm dlx shadcn@latest add button`  
   可以看到`Button`组件被复制粘贴到`/components/ui`目录下
2. 在`src/App.tsx`中使用`Button`组件

![Button 组件](<images/image-1. 项目初始化-1.png>)

### 2. Router: React Router v6.4+

1. `pnpm add react-router-dom`
2. 创建`pages`目录，代表一个个 Router 页面  
   将原本的`App.tsx`内容移到`pages`目录下，改名为`Home.tsx`，作为主页
3. 创建`src/router.tsx`，配置主页的路由：

   ```tsx
   import { createBrowserRouter } from 'react-router-dom'
   import Home from './pages/Home'

   export const router = createBrowserRouter([
     {
       path: '/',
       element: <Home />,
     },
   ])
   ```

4. 修改`src/main.tsx`，使用路由：

   ```tsx
   import { StrictMode } from 'react'
   import { createRoot } from 'react-dom/client'
   import { RouterProvider } from 'react-router-dom'
   import { router } from './router'
   import './index.css'

   createRoot(document.getElementById('root')!).render(
     <StrictMode>
       <RouterProvider router={router} />
     </StrictMode>
   )
   ```

至此，基本的 Router 已配置完成，以后可以在此基础上完善。

### 3. i18n: React i18next

如果确定要做国际化，则越早做越好，且全局贯穿使用，避免日后更改成本高昂。  
目前最简单的技术栈就是`i18next`

1. 安装相关包: `pnpm add i18next react-i18next i18next-browser-languagedetector`  
   其中`i18next-browser-languagedetector`用于自动检测浏览器语言
2. 创建 i18n 配置
   1. 创建`i18n/index.ts`

      ```ts
      // 暂时把翻译写在这里，以后会提取到 json 文件
      const resources = {
        en: {
          translation: {
            welcome: 'Hello World!',
            count: 'Count is {{count}}',
          },
        },
        zh: {
          translation: {
            welcome: '你好，世界！',
            count: '当前计数：{{count}}',
          },
        },
      }

      i18n
        .use(LanguageDetector) // 自动检测浏览器语言
        .use(initReactI18next)
        .init({
          resources,
          fallbackLng: 'en',
          interpolation: {
            escapeValue: false, // React 已经防范了 XSS，所以这里不需要
          },
        })

      export default i18n
      ```

   2. 在`src/main.tsx`中使用i18n
      ```tsx
      import './i18n'
      ```
      ⚠ 注意：不能是`import i18n from './i18n'`，否则会因为没有被使用**而被优化掉**（而`import './i18n'`是 Side-Effect Import，会执行文件里的代码）  
      ![踩坑 - Side-Effect Import](<images/image-1. 项目初始化-2.png>)
   3. 在 Home page 使用：

      ```tsx
      function Home() {
        const { t, i18n } = useTranslation();

        const [count, setCount] = useState(0);

        return (
          <>
            <div className="flex flex-col items-center justify-center h-screen">
              <h1 className="text-3xl font-bold underline mb-4">{t('welcome')}</h1>
              <h1 className="text-3xl font-bold mb-4">{i18n.language}</h1>
              <Button className="mb-4" onClick={() => setCount(count + 1)}>{t('count', { count })}</Button> // 这是传参数的用法，对应 i18n 中的 {{count}}（如果是{{abc}}，则这里为{ abc: count }）
              <Button className="mb-4" onClick={() => i18n.changeLanguage(i18n.language === 'zh' ? 'en' : 'zh')}>{t('switch-language')}</Button>
            </div>
          </>
        )
      }
      ```

![最终效果](<images/image-1. 项目初始化-3.png>)

> 我原本计划在这里就将 i18n 放到`/packages`下抽离出去，但 GPT 告诉我这样会增加配置复杂度，是“为了配置而配置”，并且现在目标是尽快跑通，  
> 建议等日后开发第二个应用（如`admin`），才能针对真实需求和痛难点进行提取，故这里也暂时放在本项目 Local 下。

## 4. 配置辅助工具: ESLint + Prettier + Commitlint

### 1. ESLint + lint-staged

_这部分还暂时不清楚，先这么用着，日后详细进行规范。_

根目录创建`eslint.config.js`：

```js
import js from '@eslint/js'
import globals from 'globals'

export default [
  { ignores: ['dist', 'node_modules', 'coverage', 'apps/**/dist'] },
  js.configs.recommended,
  {
    languageOptions: {
      ecmaVersion: 2022,
      sourceType: 'module',
      globals: {
        ...globals.browser,
        ...globals.node,
      },
    },
  },
]
```

这个用于检查根目录的脚本文件，各个子应用应该有自己的 ESLint 配置。

`package.json`中添加：

```json
{
  "lint-staged": {
    "*.{js,jsx,ts,tsx}": ["prettier --write", "eslint --fix"],
    "*.{json,css,md}": ["prettier --write"]
  }
}
```

这个用于对未提交的文件，js、jsx、ts、tsx 文件进行格式化和检查，json、css、md 文件只进行格式化。

### 2. Prettier

根目录创建`.prettierrc`：

```json
{
  "semi": false,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5",
  "printWidth": 100,
  "plugins": ["prettier-plugin-tailwindcss"]
}
```

### 3. Commitlint

根目录创建：

```json
{
  "extends": ["@commitlint/config-conventional"],
  "rules": {
    "scope-enum": [1, "always", ["web", "admin"]], // (scope) 限定
    "type-enum": [
      2,
      "always",
      ["feat", "fix", "docs", "style", "refactor", "test", "perf", "chore", "ci", "build", "revert"]
    ] // (type) 限定
  }
}
```

## 5. 初始化仓库，配置 Husky 流程，首次提交

自行创建`.gitignore`文件。

```bash
# 1. 初始化 Git
git init

# 2. 安装 Husky (生成 .husky 目录)
pnpm dlx husky init
```

husky v9 需要手动添加：

- pre-commit: 提交前运行 lint-staged  
  在`.husky`目录下自带的`pre-commit`文件后追加：

```bash
npx lint-staged
```

- commit-msg: 提交时检查 message 格式
  在`.husky`目录下创建`commit-msg`文件，内容为：

```bash
pnpm commitlint --edit $1
```

然后，提交！

```bash
git add .
git commit -m "chore: project initialization"
```

## 6. 组件单元测试: Vitest + React Testing Library + jsdom

1. 在 shop-web 下安装相关包：

```bash
pnpm add -D vitest @testing-library/react @testing-library/dom @testing-library/jest-dom jsdom
```

2. 创建 vitest.config.ts

```ts
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react-swc'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: './src/test/setup.ts',
  },
})
```

3. 创建测试的配置 Setup 文件：在`src/test/setup.ts`中添加：

```ts
import '@testing-library/jest-dom'
```

4. 【验证】编写简单测试，`src/App.test.tsx`：

```tsx
import { render, screen } from '@testing-library/react'
import { describe, it, expect } from 'vitest'
import { Button } from '@/components/ui/button'

describe('Button Component', () => {
  it('renders correctly', () => {
    render(<Button>Click me</Button>)
    expect(screen.getByText('Click me')).toBeInTheDocument()
  })
})
```

5. 运行测试

```bash
pnpm vitest
```

或者在`package.json`中添加脚本：

```json
{
  "scripts": {
    "test": "vitest"
  }
}
```

然后`pnpm run test`。

> **有关测试**：
>
> 个人之前一直对测试感到疑惑和神奇，其一是之前开发都没怎么关注测试，并没有因为没测试而带来很大问题；其二是之前代码体量很小，感觉测试没用，而如果体量大了，又不知道测什么；第三是教学都太脱离实际，总是测`1+1=2`这种很显而易见的东西，更加觉得测试没必要/不知道必要的测试是什么。
> 故虽然知道测试很重要，但最主要的问题是不知道测什么/怎么测，只能慢慢积累经验。
>
> 比如这里 GPT 生成的 4类：
>
> - 渲染 (Rendering): 确保组件能正常显示内容。  
>   意义: 防止某次改动导致组件直接白屏或内容丢失。
> - 变体 (Variants): 确保 variant="destructive" 真的加上了红色的 class。  
>   意义: 这是 Shadcn UI/Tailwind 的核心。防止你误删了配置，导致所有“删除按钮”变回了默认颜色，用户不敢点了。
> - 多态性 (Polymorphism): 确保 asChild 属性工作正常（这是 Radix UI 的核心特性）。  
>   意义: 确保 <Button asChild><a href="...">Login</a></Button> 既有按钮的样子，又是 <a> 标签（利于 SEO 和无障碍）。如果这个功能坏了，你的链接可能就跳不过去了。
> - 交互 (Interaction): 确保 onClick 能够透传。  
>   意义: 防止你在组件内部写死了一些逻辑，导致外部传进来的 onClick 失效。
>
> 测试的对象和方法：
>
> - 基础组件 (Button, Input): 写一次，受益终身。因为它们被全项目复用，一点小 bug 就会炸全场。
> - 业务组件 (ProductCard): 测业务逻辑。比如“价格是否格式化了？”“库存为 0 时按钮是否禁用了？”。
> - 页面 (Page): 通常写集成测试（E2E），模拟用户完整操作流程，而不是测细节。

## 一些知识记录

### 1. public 和 src/assets 的区别

- public: 静态资源，直接复制到 dist 目录，不会被压缩、加 hash 等，**可直接在 HTML 中使用**  
  通常是 favicon.ico, robots.txt
- src/assets: 资源文件，会经过 Vite/Webpack 处理，**不能直接在 HTML 中使用，而是在 JS 中引用**
