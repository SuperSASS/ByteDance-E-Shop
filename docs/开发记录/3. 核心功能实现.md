# 0x03 核心功能实现

实现商品页面，主要包括以下核心功能：

- 展示：Gird 网格卡片展示核心信息，图片、名称、描述、价格、销量、评分等
- 筛选：基于类别、价格、销量、评分等维度进行组合筛选
- 排序：价格、销量、上架时间，升降序
- 分页：分页控制，页码切换、每页条数选择

## 1. 数据模型设计

首先构建商品模型：

有五个大的类别（`mainCategory`）：电脑、手机、平板、声响设备、配件。五个设备各自有以下属性（`attributes`/`subCategories`）：

- 电脑
  - 类型：游戏电脑、商务电脑、超极本、工作站
  - CPU：Intel i5、Intel i7、Intel i9、AMD Ryzen 5、AMD Ryzen 7、AMD Ryzen 9、Apple M2、Apple M3
  - 内存：8GB、16GB、32GB、64GB
  - GPU：NVIDIA RTX 3060、NVIDIA RTX 4060、NVIDIA RTX 4070、集成
- 手机
  - 系列：Pro、Standard、Ultra、Fold
  - 存储：128GB、256GB、512GB、1TB
  - 是否防水：是、否
- 平板
  - 尺寸：8-inch、10-inch、11-inch、12.9-inch
  - 操作系统：Android 12、Android 13、HarmonyOS
- 声响设备
  - 类型：耳机、耳塞、扬声器
  - 连接：蓝牙、有线
  - 功能：降噪、标准
- 配件
  - 类型：外壳、充电器、数据线、键盘、鼠标
  - 兼容：通用、Apple、USB-C

然后每个商品的 Model 为：

```js
export interface Product {
    id: string
    name: LocalizedString // 名称 (i18n)
    description: LocalizedString // 描述 (i18n)
    price: number // 当前价格
    originalPrice?: number // 原始价格（如果当前为折扣价，则存在该属性）
    rating: number // 评分
    sales: number // 销量（当月）
    image: string // 主图
    images: string[] // 详情图

    mainCategory: MainCategory // 主类别
    attributes: Partial<SubCategories['PC'] & SubCategories['Phone'] & SubCategories['Tablet'] & SubCategories['Audio'] & SubCategories['Accessories']> // 主类别下的属性

    createdAt: string // 上架时间
}
```

其中`LocalizedString`为`Record<string, string>`，以支持 i18n。

## 2. 简易后端搭建与对接

### 1. Express 后端搭建

为了加深前后端全流程了解，同时真正用上 monorepo 仓库架构，故用 Express 搭建一个简易的后端，实现商品和用户两个领域。

将数据 mock 转到后端中实现，前端正常调用 API 接口获取数据。

后端 API 接口`http://localhost:3000/api`：

- `/products`：获取商品列表  
  这里会解析各种筛选条件，只返回符合条件的商品
- `/products/:id`：获取商品详情
- `/auth/login`：登录
- `/auth/me`：获取当前登录用户信息

### 2. Shared 层抽象

由于开始有了不同的项目，故将多个项目之间共享的类型、工具函数等抽象到 shared 包，在其中可以定义 DTO（数据传输对象）。

新建`packages/shared`包，将之前分散在前后端对商品 Product、用户模型常量和 DTO 的定义，统一到 shared 包中。

### 3. 前后端对接

创建服务`userService`和`productService`，分别用于处理用户和商品的 API 服务请求。

- `userService`：处理用户登录、获取当前登录用户信息等
  - `login`：根据邮箱密码邓丽，获取 token。目前未考虑加密安全
  - `getCurrentUser`：根据 token 获取用户信息
- `productService`：处理商品列表、商品详情等
  - `getProducts`：获取商品列表  
    这里是处理筛选的逻辑所在：通过 URL Query 参数(`?`)获取并构造筛选条件
  - `getProductById`：获取商品详情

最后需要在`vite.config.ts`中配置代理，将 API 请求`/api`代理到后端`http://localhost:3000/api`。

## 3. 开发商品页面

整体布局（桌面端）：

- 上方面包屑导航：展示主分类
- 左侧筛选区：展示筛选条件
  - 主类别，点进去后是对应的属性
  - 标签：新品、热销、折扣
  - 价格
  - 评分
- 右侧商品展示区：网格展示商品列表

对于移动端，则使用 Sheet 展示筛选区。

### 1. 组件与页面开发

一共由三个组件组成：

- `FilterSidebar`：筛选区
  - 按关键词（标题）筛选商品
  - 按主类别筛选商品  
    当进入某一类别时，则变成按该类别的属性筛选商品
  - 按标签筛选上哦
  - 按价格筛选商品
  - 按评分筛选商品
- `ProductGrid`：商品网格布局
  - 处理加载状态
  - 处理空结果状态
  - 通过 grid 布局展示`ProductCard`
- `ProductCard`：商品卡片展示
  - 展示商品信息：图片、标签、名称、描述、评分、价格、销量、操作按钮

然后在 Product Page，则按照上面的设计进行组合。

### 2. 核心逻辑实现

筛选、分页、排序三个功能，都基于 URLSearchParams 实现。  
当用户进行筛选、分页、排序操作时，会修改 URLSearchParams，后端会根据 URLSearchParams 返回对应筛选好、排好序、分好页的商品列表。

#### 1. 筛选功能：筛选条件变动时，重新加载数据

这里的核心机制原理是：**利用 React Router 提供的 URLSearchParams API(`useSearchParams`)**。  
当筛选条件变化时，在`<FilterSidebar>`组件中，通过`setSearchParams`设置对应条件的 URL query（即`product?xxx=yyy`），  
`<ProductPage>`再通过`useEffect`监听`searchParams`，如果变化则基于当前 URL 的 `searchParams` 重新加载数据，后端也会根据 `searchParams` 进行筛选，返回对应的商品列表。

同时为了优化体验，还需要实现：

- 当关闭类别(Catetory)时，需要清空其中所选的属性(Attribute)  
  否则到其他类别时，会因基本不存在这些属性（每个类别的属性是独立的）导致筛选条件无效，从而导致商品列表为空。

#### 2. 分页功能：点击页码跳转对应页

仍然是利用 URLSearchParams，点击页面后修改 query 参数，  
后端返回的结果会自行分页，Response 包含`items`、`total`、`page`、`pageSize`这四个字段。

#### 3. 排序功能：按照排序选项排序商品

同上面。

### 3. 其它逻辑实现

#### 1. 切换页码时，滚动到页顶

- 因为对 root 使用了 `overflow-hidden` 隐藏滚动条，而现在显示的滚动条是其中的`<main>`，故直接用 `window.scrollTo` 没有用
- 因此需要对 `<main>` 创建 Ref（`<main ref={mainRef} ...>`），为了方便再创建 `scrollToTop` 方法，最后通过 Outlet 的 context 机制（React Router v6.4+）将该方法以 `context` 形式提供给子组件（子组件用 `useOutletContext` 来获取）
- 在子组件中获取并调用 `scrollToTop` 方法，便可滑动到顶部。

MainLayout 组件：

```tsx
export interface MainLayoutContext {
  scrollToTop: () => void
}

function MainLayout() {
  const mainRef = useRef<HTMLElement>(null)

  const scrollToTop = () => {
    mainRef.current?.scrollTo({ top: 0, behavior: 'smooth' })
  }

  return (
      <Header />
      <main ref={mainRef}>
          <Outlet context={{ scrollToTop } satisfies MainLayoutContext} />
      </main>
  )
}
```

子组件：

```tsx
const { scrollToTop } = useOutletContext<MainLayoutContext>()
```

#### 2. 筛选防抖和避免竞态

如果没有防抖，会因筛选条件频繁变化、短时间多次请求服务器造成压力；  
如果不避免竞态，可能同时发起多个请求，最早但慢返回的结果会覆盖最新但快返回的结果，导致商品列表不正确。

**对于防抖**，可以使用`use-debounce`库；

```bash
npx usehooks-cli@latest add use-debounce
```

然后在`Product`页面中，将原来监听`searchParams`更改后就立刻重新请求的逻辑，改为使用防抖：

```tsx
const [searchParams, setSearchParams] = useSearchParams()

// 添加防抖：当 URL searchParams 变化时，延迟 500ms 再重新加载数据
const debouncedSearchParams = useDebounce(searchParams, 500)

// 当 debouncedSearchParams 变化时加载数据（防抖处理）
// 原理：筛选条件改变 -> debouncedSearchParams 变化（在 FilterSidebar 中 setSearchParams） -> loadData 加载筛选后的数据
useEffect(() => {
  loadData()
}, [debouncedSearchParams])
```

**对于避免竞态**，这里可以使用`React Query`库来重新管理服务器请求，该库基于`takeLatest`默认处理竞态问题。

安装后在 ProductPage 中，首先在`main.tsx`中创建`QueryClient`并包裹`<QueryClientProvider>`，  
然后在`ProductPage`中，将原来的获取数据方法改使用`useQuery`来管理服务器请求：

```tsx
const { data, isLoading } = useQuery({
  queryKey: ['products', debouncedSearchParams.toString()],
  queryFn: () => productService.getProducts(debouncedSearchParams),
})
```
